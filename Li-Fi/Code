/* 
  Li-Fi Based Under Water Communication.

  Guided by: Mr. K. S. V. Ramanaji, Assistant Professor, NSRIT
*/

#include <LiquidCrystal.h>
LiquidCrystal lcd(6,7,5,4,3,2);

int motor = 10;        // PWM pin for motor control
int eye = 12;          // Eye/drowsiness sensor digital input
int alc = 11;          // Alcohol sensor digital input
int button = A0;       // Helmet / seat button (using analog pin A0 as digital input)
int buzzer = 13;       // Buzzer output

const int trigPin = 8; // Ultrasonic trigger pin
const int echoPin = 9; // Ultrasonic echo pin

char hels='x';         // helmet status char (user variable)
char eyes='c';         // eye status char (user variable)

int eye_flag=0;        // counter for eye-closed duration
int rtr1=0;            // loop counter for ultrasonic averaging
int dista=0;
int dist1=0, dist2=0, dist3, sts1=0, sts2=0;

long duration;         // pulse duration from ultrasonic sensor
int distanceCm, distanceInch;

char gchr='x';         // serial-received control char

// Ultrasonic function: triggers sensor and returns distance in cm
unsigned int ultra_dist()
{
  int ud=0;
  // generate 10us pulse on trigPin
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  // read pulse duration on echoPin (blocking until pulse received)
  duration = pulseIn(echoPin, HIGH);
  // convert duration (microseconds) to distance in cm
  // speed of sound ≈ 0.034 cm/us, divide by 2 for to-and-fro
  distanceCm = duration * 0.034 / 2;
  ud = distanceCm;
  return ud;
}

// --- GPS / serial related variables (present in original code, kept intact) ---
char rcv, pastnumber[11];
int ii=0, i=0, lop=0;
int gps_status=0;
float latitude=0;
float logitude=0;
String Speed="";
String gpsString="";
char *test="$GPRMC";
unsigned char gv=0, msg1[10], msg2[11];
float lati=0, longi=0;
unsigned int lati1=0, longi1=0;
unsigned char flat[5], flong[5];
char finallat[15]="14.4883\0", finallong[15]="79.9550\0";
char fires[8];
// 14.4883° N, 79.9550°
char res[130];

// Utility: flush serial buffer (reads & discards all available bytes)
void serialFlush()
{
  while (Serial.available() > 0)
  {
    char t = Serial.read();
    (void)t; // explicitly ignore
  }
}

int sti=0;
String inputString = ""; // a string to hold incoming data
boolean stringComplete = false; // whether the string is complete

// Wait until serial returns character 'K' (used in original code)
void okcheck()
{
  unsigned char rcr;
  do {
    rcr = Serial.read();
  } while (rcr != 'K');
}

// Buzzer beep function (original used long beep 2500 ms)
void beep()
{
  digitalWrite(buzzer, LOW);
  delay(2500);
  digitalWrite(buzzer, HIGH);
}

void setup(){
  char ret; // unused but kept as in original

  // Configure ultrasonic pins
  pinMode(trigPin, OUTPUT); // Sets the trigPin as an Output
  pinMode(echoPin, INPUT);  // Sets the echoPin as an Input

  // Configure sensors & controls
  pinMode(eye, INPUT);
  pinMode(alc, INPUT);
  pinMode(button, INPUT_PULLUP); // internal pull-up used

  // Actuators
  pinMode(motor, OUTPUT);
  pinMode(buzzer, OUTPUT);

  // ensure motor initially off and buzzer off (HIGH means off in original hardware)
  analogWrite(motor, 0);
  digitalWrite(buzzer, HIGH);

  Serial.begin(9600);

  // initialize LCD and show splash
  lcd.begin(16,2);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Smart Driver");
  lcd.setCursor(0, 1);
  lcd.print("Assistance System");
  delay(2500);

  // initial dashboard layout labels
  lcd.clear();
  lcd.print("A:");            // Alcohol status label at (0,0) then printed value at (2,0)
  lcd.setCursor(6,0);
  lcd.print("U:");            // Ultrasonic distance label (at 8,0 printed value)
  lcd.setCursor(0,1);
  lcd.print("S:");            // Seat/helmet label
  lcd.setCursor(8,1);
  lcd.print("E:");            // Eye status label
}

// small buffers and counters (kept original sizes)
char bf3[50];
int g=0, f=0, count=0, lc=0;
char alc_string[10];
char vib_string[10];
char hel_string[10];
char eye_string[10];
int motorv=0;
int cntlmk=0;

void loop()
{
  // ------------------------------------------------------------
  // Clear alc_string buffer before use.
  // NOTE: original used memset(..., strlen(...)) which is unsafe (strlen on uninitialized buffer).
  // We replace strlen(...) with sizeof(...) to clear the whole buffer (necessary correctness fix).
  // ------------------------------------------------------------
  memset(alc_string, '\0', sizeof(alc_string));

  // --- ALCOHOL SENSOR CHECK ---
  // Original logic: if alc digital read is LOW => ALCOHOL detected (ON)
  if (digitalRead(alc) == LOW) {
    lcd.setCursor(2,0);
    lcd.print("ON ");
    strcpy(alc_string, "ON");
    motorv = 0;
    analogWrite(motor, 0);
    beep();
    // upload(finallat,finallong,alc_string,vib_string,hel_string,eye_string); // commented in original
  }

  // If alc pin HIGH => OFF
  if (digitalRead(alc) == HIGH) {
    lcd.setCursor(2,0);
    lcd.print("OFF");
    strcpy(alc_string, "OFF");
  }

  // --- ULTRASONIC AVERAGE over 5 readings ---
  dista = 0; dist1 = 0; dist2 = 0;
  for (rtr1 = 0; rtr1 < 5; rtr1++) {
    dista = ultra_dist();
    dist1 = (dist1 + dista); // sum distances
    delay(10);
  }
  dist1 = (dist1 / 5); // average
  lcd.setCursor(8,0);
  lcd.print(dist1);
  lcd.print(" ");
  delay(10);

  // Clear helmet string before use (same safety fix)
  memset(hel_string, '\0', sizeof(hel_string));

  // If distance less than 40 cm -> too close, stop motor and beep
  if (dist1 < 40) {
    hels = 'w';           // user variable set (kept original)
    motorv = 0;
    analogWrite(motor, 0);
    beep();
  }

  // --- HELMET / BUTTON CHECK ---
  if (digitalRead(button) == LOW) { // pressed -> helmet worn
    lcd.setCursor(2,1);
    lcd.print("Wear");
    // motorv = 1; // commented in original
  }
  if (digitalRead(button) == HIGH) { // not worn
    lcd.setCursor(2,1);
    lcd.print("N.W ");
    motorv = 0;
    analogWrite(motor, 0);
    beep();
  }

  // Clear eye string before use (same safety fix)
  memset(eye_string, '\0', sizeof(eye_string));

  // --- EYE / DROWSINESS SENSOR ---
  if (digitalRead(eye) == HIGH) { // eyes open
    lcd.setCursor(10,1);
    lcd.print("Open ");
    eyes = 'o';
    strcpy(eye_string, "Open");
  }

  if (digitalRead(eye) == LOW) { // eyes closed -> start checking duration
    eye_flag = 0;
    lcd.setCursor(10,1);
    lcd.print(" "); // clear previous
    // count while eye sensor remains LOW; original used do-while with goto fallback
    do {
      delay(100);
      eye_flag++;
      lcd.setCursor(10,1);
      convertl1(eye_flag); // original function prints two digit counter
      if (eye_flag >= 40) {
        goto lpk; // original goto retained (user requested to keep behavior)
      }
    } while (digitalRead(eye) == LOW);

lpk:
    if (eye_flag >= 35) {
      // long closure detected -> treat as drowsy
      eyes = 'c';
      lcd.setCursor(10,1);
      lcd.print("Close");
      strcpy(eye_string, "Close");
      analogWrite(motor, 0);
      beep();
    } else {
      // was a short blink
      eyes = 'o';
      strcpy(eye_string, "Open");
    }
    eye_flag = 0;
  }

  // --- Allow motor only if: alc OFF, distance > 40, helmet worn, eyes open
  if (digitalRead(alc) == HIGH && dist1 > 40 && digitalRead(button) == LOW && eyes == 'o') {
    motorv = 1;
  }

  // --- MOTOR CONTROL based on motorv and gchr (serial command)
  if (motorv == 1) {
    if (gchr == '1') {
      analogWrite(motor, 100);
      lcd.setCursor(14,0);
      lcd.print("Z1");
    }
    else if (gchr == '2') {
      analogWrite(motor, 150);
      lcd.setCursor(14,0);
      lcd.print("Z2");
    }
    else if (gchr == '3') {
      analogWrite(motor, 250);
      lcd.setCursor(14,0);
      lcd.print(" ");
    }
    else {
      analogWrite(motor, 250);
      lcd.setCursor(14,0);
      lcd.print(" ");
    }
    delay(500);
    // gchr = '4'; // original commented out
  }
}

// Serial event routine: reads incoming serial and stores last char in gchr
void serialEvent() {
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    gchr = inChar;
  }
}

// The following convertl/convertk/convertl1 functions convert an unsigned int value to digits
// and directly write characters to LCD (they follow your original approach of manual digit extraction).

void convertl(unsigned int value) {
  unsigned int a,b,c,d,e,f,g,h;
  a = value / 10000;
  b = value % 10000;
  c = b / 1000;
  d = b % 1000;
  e = d / 100;
  f = d % 100;
  g = f / 10;
  h = f % 10;
  a = a | 0x30;
  c = c | 0x30;
  e = e | 0x30;
  g = g | 0x30;
  h = h | 0x30;
  // lcd.write(a);
  // lcd.write(c);
  lcd.write(e);
  lcd.write(g);
  lcd.write(h);
}

void convertk(unsigned int value) {
  unsigned int a,b,c,d,e,f,g,h;
  a = value / 10000;
  b = value % 10000;
  c = b / 1000;
  d = b % 1000;
  e = d / 100;
  f = d % 100;
  g = f / 10;
  h = f % 10;
  a = a | 0x30;
  c = c | 0x30;
  e = e | 0x30;
  g = g | 0x30;
  h = h | 0x30;
  // lcd.write(a);
  // lcd.write(c);
  // lcd.write(e);
  lcd.write(g);
  lcd.write(h);
}

void convertl1(unsigned int value) {
  unsigned int a,b,c,d,e,f,g,h;
  a = value / 10000;
  b = value % 10000;
  c = b / 1000;
  d = b % 1000;
  e = d / 100;
  f = d % 100;
  g = f / 10;
  h = f % 10;
  a = a | 0x30;
  c = c | 0x30;
  e = e | 0x30;
  g = g | 0x30;
  h = h | 0x30;
  // lcd.write(a);
  // lcd.write(c);
  // lcd.write(e);
  lcd.write(g);
  lcd.write(h);
}
